"""
Polyrifringence Engine Documentation Generator

Auto-generate academic papers, technical reports, and reference materials
from Polyrifringence Engine analysis results.
"""

import json
import datetime
import torch
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
import re


@dataclass
class PaperMetadata:
    """Metadata for academic paper generation"""
    title: str
    authors: List[str]
    affiliation: str
    abstract: str
    keywords: List[str]
    date: str = None

    def __post_init__(self):
        if self.date is None:
            self.date = datetime.datetime.now().strftime("%B %d, %Y")


class DocumentationGenerator:
    """
    Generate various documentation formats from engine results
    """

    def __init__(self, engine):
        """
        Initialize documentation generator with Polyrifringence Engine
        """
        self.engine = engine
        self.templates = {}
        self._initialize_templates()

    def _initialize_templates(self):
        """
        Initialize documentation templates
        """
        self.templates['report'] = """
# {title}

**Generated:** {date}
**Engine Version:** Polyrifringence Engine © Conner Brown-Milliken
**ΔΩΩΔ-Validated Framework**

---

## Executive Summary

{summary}

---

## Technical Details

### Configuration
{config_details}

### Results
{results_details}

---

## Analysis

{analysis_details}

---

## Conclusions

{conclusions}

---

## Appendix

{appendix}

---

*This report was auto-generated by the Polyrifringence Engine Documentation Generator*
"""

        self.templates['paper'] = """
# {title}

**Authors:** {authors}
**Affiliation:** {affiliation}
**Date:** {date}

---

## Abstract

{abstract}

---

## 1. Introduction

{introduction}

---

## 2. Methodology

{methodology}

---

## 3. Results

{results}

---

## 4. Analysis

{analysis}

---

## 5. Discussion

{discussion}

---

## 6. Conclusions

{conclusions}

---

## References

{references}

---

## Keywords

{keywords}

---

*This paper was auto-generated by the Polyrifringence Engine Documentation Generator*
"""

        self.templates['presentation'] = """
# {title}

## Slide 1: Title

{title}

**{authors}**

---

## Slide 2: Overview

{overview}

---

## Slide 3: Methodology

{methodology}

---

## Slide 4: Results

{results}

---

## Slide 5: Analysis

{analysis}

---

## Slide 6: Conclusions

{conclusions}

---

*Generated with Polyrifringence Engine*
"""

    def generate_analysis_report(self,
                                 results: Dict,
                                 analysis: Dict,
                                 title: str = "Polyrifringence Engine Analysis Report") -> str:
        """
        Generate comprehensive analysis report

        Args:
            results: Results from engine.run_recursion()
            analysis: Analysis from analysis_toolkit
            title: Report title

        Returns:
            Formatted report string
        """
        hl_sec = float(results.get('half_life_sec', results.get('half_life', 0.0)))
        hl_cycles = results.get('half_life_cycles', None)
        dt_cycle = float(results.get('delta_t_cycle', getattr(self.engine.config, 'delta_t_cycle', 0.0)))
        lambda_mode = str(results.get('lambda_mode', getattr(self.engine.config, 'lambda_mode', 'ratio_abs')))
        strict_canon = bool(results.get('strict_canon', getattr(self.engine.config, 'enforce_delta_omega_bound', True)))
        relay_enabled = bool(results.get('observer_feedback_enabled', getattr(self.engine.config, 'observer_feedback_enabled', False)))

        bound_hit = bool(results.get('delta_omega_bound_hit', False))
        closure_evaluated = bool(results.get('closure_evaluated', True))
        term_reason = str(results.get('termination_reason', 'unknown'))

        summary = f"""
The Polyrifringence Engine executed a recursive birefringence simulation with the following outcomes:

• **Numerical Convergence:** {'Achieved' if results['converged'] else 'Not Achieved'}
• **Termination Reason:** {term_reason}
• **ΔΩ Bound Hit:** {'Yes' if bound_hit else 'No'}
• **Cycle Count:** {results['cycle_count']} (ΔΩ constraint: 6-7 cycles)
• **AΩ Closure:** {'Not evaluated (ΔΩ-bounded termination)' if not closure_evaluated else ('Achieved' if results['closure_achieved'] else 'Not Achieved')}
• **Exergy Half-Life (sec):** {('∞' if hl_sec == float('inf') else f'{hl_sec:.4f}s')} (canonical envelope: 0.18–0.24s)
• **Exergy Half-Life (cycles):** {('∞' if hl_cycles == float('inf') else f'{hl_cycles:.2f}')}  (Δt_cycle={dt_cycle:.6f}s)
• **λ_mode:** {lambda_mode}
• **Strict Canon:** {'ON' if strict_canon else 'OFF'}
• **Observer Relay (diagnostic):** {'ON' if relay_enabled else 'OFF'}

{f'Within ΔΩ bound: Yes' if results['cycle_count'] <= 7 else 'Within ΔΩ bound: No'}
        """.strip()

        config_details = f"""
**Device:** {self.engine.device}
**Data Type:** {self.engine.dtype}
**Convergence Threshold:** {self.engine.config.convergence_threshold}
**ΔΩ Parameter:** {self.engine.config.delta_omega}
**Exergy Half-Life Range:** {self.engine.config.exergy_half_life}
        """.strip()

        results_details = f"""
**Final Energy State:**
   E_final = {results['final_E']}
   
**Metrics Over Cycles:**
"""

        history = results['history']
        for i in range(min(5, results['cycle_count'])):
            results_details += f"""
Cycle {i+1}:
  • Phase Variance: {history['phase_variance'][i]:.6e}
  • Exergy: {history['exergy'][i]:.6e}
  • Decay Rate: {history['decay_rate'][i]:.6e}
"""

        stability_line = (
            'ΔΩ-bounded termination: non-monotonic phase variance is admissible; numeric settling is intentionally not required.'
            if bound_hit else
            ('System is stable and converging monotonically' if analysis['monotonically_converging'] else 'System shows non-monotonic behavior - investigate anomalies')
        )

        analysis_details = f"""
**Trace Analysis:**
• Phase Variance Trend: {analysis['phase_variance_trend']:.6e}
• Exergy Trend: {analysis['exergy_trend']:.6e}
• Convergence Rate: {analysis['convergence_rate']:.6e}
• Monotonically Converging: {analysis['monotonically_converging']}
• Total Exergy Loss: {analysis['exergy_loss']:.6e}

**Stability Assessment:**
{stability_line}
        """.strip()

        if bound_hit:
            conclusions = """
The run terminated under the ΔΩ admissibility cap (canonical termination at 6–7 cycles).

Interpretation (canonical):
1. **ΔΩ-bounded admissibility:** The recursion was intentionally halted at the bound; numerical convergence is not a required success condition in this mode.
2. **AΩ closure:** Not evaluated under ΔΩ-bounded termination.
3. **Λ̸ half-life:** The reported half-life is computed from the selected λ_cycle definition and converted to seconds using Δt_cycle.
4. **Thermodynamic legality:** No energy creation or amplification is implied; the engine only structures existing energy temporally.
            """.strip()
        elif results['converged'] and results['cycle_count'] <= 7:
            conclusions = """
The simulation demonstrates successful operation within ΔΩ constraints:

1. **Coherence Achievement:** System converged within {0} cycles, satisfying the ΔΩ coherence law (6-7 cycles expected).

2. **Identity Closure:** Closure achieved, confirming AΩ principle compliance.

3. **Exergy Dynamics:** Half-life of {1} falls {2} the expected range [0.18, 0.24]s, indicating {3} exergy performance.

4. **Energy Conservation:** Unitary constraints maintained throughout recursion.

5. **System Stability:** Monotonically converging phase variance confirms system stability.

The engine operates within established thermodynamic bounds, extending exergy half-life through structural organization rather than energy creation.
            """.format(
                results['cycle_count'],
                ('∞' if hl_sec == float('inf') else f"{hl_sec:.4f}s"),
                "within" if (hl_sec == float('inf') or 0.18 <= hl_sec <= 0.24) else "outside",
                "acceptable" if (hl_sec == float('inf') or 0.18 <= hl_sec <= 0.24) else "suboptimal"
            ).strip()
        else:
            conclusions = """
The simulation shows non-ideal behavior:

1. **Convergence Issues:** System {0} converge within expected cycles.

2. **Closure Status:** {1}

3. **Parameter Adjustment:** Consider adjusting ΔΩ, convergence threshold, or initial conditions.

Recommendations:
• Review initial polarization state
• Check rotation angle and wavelength sequences
• Verify ΔΩ parameter setting
• Consider increasing convergence threshold for complex systems
            """.format(
                "did" if not results['converged'] else "did but outside ΔΩ bounds",
                "achieved" if results['closure_achieved'] else "not achieved"
            ).strip()

        # FIX: escape braces inside f-string blocks so {n+1} is literal
        appendix = f"""
## Mathematical Framework

**Jones Matrix:**
E' = J(θ, λ) · E

**Recursive Feedback:**
E_{{n+1}} = J(θ_n, λ_n) · F(E_n)

**ΔΩ Constraint:**
λ_cycle^(ΔΩ) < λ_cycle^(raw)

**Exergy Half-Life:**
t₁/₂ = ln(2) / λ_cycle

## Operator Definitions

**ΔΩ (Delta-Omega):** Coherence law ensuring drift collapse in 6-7 cycles
**Λ̸ (Lambda-dot):** Exergy half-life operator (t₁/₂ ∈ [0.18, 0.24]s)
**AΩ (Alpha-Omega):** Identity closure principle
**ZPEx:** Zero-Point Exergy operator

## Non-Claims Framework

This work represents an extension of applied physics through controlled non-equilibrium structuring:
• No new physical laws are proposed
• No energy is created, regenerated, or amplified
• No entropy is eliminated or reversed
• All gains from reduced exergy destruction rates and structural organization
        """.strip()

        report = self.templates['report'].format(
            title=title,
            date=datetime.datetime.now().strftime("%B %d, %Y at %H:%M"),
            summary=summary,
            config_details=config_details,
            results_details=results_details,
            analysis_details=analysis_details,
            conclusions=conclusions,
            appendix=appendix
        )

        return report

    def generate_academic_paper(self,
                               metadata: PaperMetadata,
                               results: Dict,
                               analysis: Dict,
                               methodology: str = "") -> str:
        """
        Generate academic paper format
        """
        introduction = """
The Polyrifringence Engine is a GPU-accelerated recursive simulation framework that models the behavior of light passing through birefringent materials with feedback loops and symbolic constraints. This work presents a computational approach to understanding coherence preservation and exergy dynamics in recursive optical systems.

The engine combines classical optics (Jones matrices) with recursive tensor feedback and symbolic recursion to model complex optical phenomena. Key innovations include the ΔΩ coherence law, Λ̸ exergy half-life operator, and AΩ identity closure principle.

This framework operates within established thermodynamic bounds, explicitly making no claims about energy creation, entropy reversal, or new physical laws. Instead, it demonstrates how structural organization and timing alignment can extend exergy half-life through controlled non-equilibrium structuring.
        """.strip()

        if not methodology:
            methodology = f"""
## Simulation Framework

The engine implements a recursive birefringence model using the following mathematical framework:

**Base Transformation:**
E' = J(θ, λ) · E

where J(θ, λ) is the Jones matrix for rotation angle θ and wavelength λ.

**Recursive Feedback:**
E_{{n+1}} = J(θ_n, λ_n) · F(E_n)

where F(E_n) is the phase restoration operator minimizing phase variance Δφ_n = |φ_{{n+1}} - φ_n|.

**Core Operators:**

1. **ΔΩ (Delta-Omega):** Coherence law parameter (typically 1/7) ensuring drift collapse within 6-7 cycles:
   λ_cycle^(ΔΩ) < λ_cycle^(raw)

2. **Λ̸ (Lambda-dot):** Exergy half-life operator with experimentally observed range t₁/₂ ∈ [0.18, 0.24]s:
   t₁/₂ = ln(2) / λ_cycle

3. **AΩ (Alpha-Omega):** Identity closure principle ensuring ‖E_final - E_initial‖ < threshold.

**Implementation Details:**
• Device: {self.engine.device}
• Data Type: {self.engine.dtype}
• Framework: PyTorch 2.5.1
• Convergence Threshold: {self.engine.config.convergence_threshold}
• ΔΩ Parameter: {self.engine.config.delta_omega}

**Non-Claims Framework:**
No new physical laws, energy creation, or entropy reversal. All performance gains arise from reduced exergy destruction rates and structural organization.
            """.strip()

        results_text = f"""
## Recursion Performance

The simulation achieved {'convergence' if results['converged'] else 'non-convergence'} in {results['cycle_count']} cycles.

**Key Metrics:**
• Convergence Status: {results['converged']}
• Cycle Count: {results['cycle_count']} (ΔΩ constraint: 6-7 cycles)
• Closure Achieved: {results['closure_achieved']}
• Exergy Half-Life: {results['half_life']:.4f}s

**Temporal Evolution:**
"""

        history = results['history']
        for i in range(min(10, results['cycle_count'])):
            results_text += f"""
Cycle {i+1}: Phase Variance = {history['phase_variance'][i]:.6e}, Exergy = {history['exergy'][i]:.6e}
"""

        analysis_text = f"""
## Trace Analysis

**Phase Dynamics:**
• Variance Trend: {analysis['phase_variance_trend']:.6e}
• Convergence Rate: {analysis['convergence_rate']:.6e}
• Monotonic Convergence: {analysis['monotonically_converging']}

**Exergy Dynamics:**
• Exergy Trend: {analysis['exergy_trend']:.6e}
• Total Exergy Loss: {analysis['exergy_loss']:.6e}
• Exergy Loss Rate: {analysis['exergy_loss_rate']:.6e}

**Stability Assessment:**
The system demonstrates {'stable' if analysis['monotonically_converging'] else 'potentially unstable'} behavior based on phase variance evolution.
        """.strip()

        discussion = f"""
## Interpretation

The {results['cycle_count']}-cycle convergence {'satisfies' if results['cycle_count'] <= 7 else 'exceeds'} the ΔΩ constraint of 6-7 cycles, indicating {'optimal' if results['cycle_count'] <= 7 else 'suboptimal'} coherence performance.

The observed exergy half-life of {results['half_life']:.4f}s falls {'within' if 0.18 <= results['half_life'] <= 0.24 else 'outside'} the expected range [0.18, 0.24]s, suggesting {'consistent' if 0.18 <= results['half_life'] <= 0.24 else 'anomalous'} exergy dynamics.

The {'achieved' if results['closure_achieved'] else 'not achieved'} closure confirms {'AΩ' if results['closure_achieved'] else 'potential violation of'} identity closure principle, indicating {'successful' if results['closure_achieved'] else 'incomplete'} symbolic trace continuity.

**Performance Characteristics:**
• Coherence Preservation: {'Strong' if results['converged'] and results['cycle_count'] <= 7 else 'Weak'}
• Exergy Utilization: {'Efficient' if 0.18 <= results['half_life'] <= 0.24 else 'Needs Optimization'}
• System Stability: {'Stable' if analysis['monotonically_converging'] else 'Investigate Anomalies'}

**Thermodynamic Legality:**
All operations maintained unitary constraints |E_{{n+1}}| ≤ |E_n|, confirming compliance with energy conservation. No energy creation or entropy reversal observed.
        """.strip()

        conclusions = """
## Summary

The Polyrifringence Engine demonstrates successful recursive birefringence simulation within thermodynamic bounds. The integration of classical optics with recursive feedback and symbolic constraints provides a novel framework for modeling coherence preservation and exergy dynamics.

Key findings:
1. ΔΩ coherence law ensures bounded convergence
2. Λ̸ exergy half-life operator characterizes usable energy persistence
3. AΩ identity closure principle maintains trace continuity
4. All operations comply with energy conservation

The framework extends applied physics through controlled non-equilibrium structuring, demonstrating performance advantages through structural organization rather than fundamental law modification.

**Future Work:**
• Domain extension beyond optical systems
• Comparative analysis with classical approaches
• Uncertainty quantification
• Multi-objective optimization
        """.strip()

        references = """
1. Brown-Milliken, C. "Polyrifringence Engine: Recursive Birefringence with Symbolic Constraints." (2024)
2. Jones, R.C. "A New Calculus for the Treatment of Optical Systems." J. Opt. Soc. Am. (1941)
3. Landauer, R. "Irreversibility and Heat Generation in the Computing Process." IBM J. Res. Dev. (1961)
4. Maxwell, J.C. "Theory of Heat." (1871)
        """.strip()

        paper = self.templates['paper'].format(
            title=metadata.title,
            authors=", ".join(metadata.authors),
            affiliation=metadata.affiliation,
            date=metadata.date,
            abstract=metadata.abstract,
            introduction=introduction,
            methodology=methodology,
            results=results_text,
            analysis=analysis_text,
            discussion=discussion,
            conclusions=conclusions,
            references=references,
            keywords=", ".join(metadata.keywords)
        )

        return paper

    def generate_presentation(self,
                             results: Dict,
                             analysis: Dict,
                             title: str = "Polyrifringence Engine Results") -> str:
        overview = f"""
The Polyrifringence Engine is a GPU-accelerated recursive simulation framework modeling birefringence with feedback loops and symbolic constraints.

**Key Features:**
• ΔΩ Coherence Law (6-7 cycle convergence)
• Λ̸ Exergy Half-Life Operator
• AΩ Identity Closure Principle
• ZPEx Zero-Point Exergy

**Performance:**
• Convergence: {results['converged']}
• Cycles: {results['cycle_count']}
• Half-Life: {results['half_life']:.4f}s
        """.strip()

        methodology = f"""
**Mathematical Framework:**
• Jones Matrix: E' = J(θ, λ) · E
• Recursive Feedback: E_{{n+1}} = J(θ_n, λ_n) · F(E_n)
• Energy Conservation: |E_{{n+1}}| ≤ |E_n|

**Core Operators:**
• ΔΩ: Coherence constraint (λ_cycle^ΔΩ < λ_cycle^raw)
• Λ̸: Exergy half-life (t₁/₂ = ln(2)/λ_cycle)
• AΩ: Identity closure (‖E_final - E_initial‖ < threshold)

**Implementation:**
• Device: {self.engine.device}
• Framework: PyTorch 2.5.1
• GPU-accelerated with CPU fallback
        """.strip()

        results_text = f"""
**Convergence Metrics:**
• Status: {'✓ Achieved' if results['converged'] else '✗ Not Achieved'}
• Cycle Count: {results['cycle_count']}/7 (ΔΩ constraint)
• Closure: {'✓ Achieved' if results['closure_achieved'] else '✗ Not Achieved'}

**Exergy Dynamics:**
• Half-Life: {results['half_life']:.4f}s
• Expected Range: [0.18, 0.24]s
• Status: {'✓ Within Range' if 0.18 <= results['half_life'] <= 0.24 else '✗ Outside Range'}

**Phase Variance Evolution:**
• Initial: {results['history']['phase_variance'][0]:.6e}
• Final: {results['history']['phase_variance'][-1]:.6e}
• Trend: {analysis['phase_variance_trend']:.6e}
        """.strip()

        analysis_text = f"""
**Stability Assessment:**
• Monotonic Convergence: {'✓ Yes' if analysis['monotonically_converging'] else '✗ No'}
• Convergence Rate: {analysis['convergence_rate']:.6e}
• Stability Status: {'✓ Stable' if analysis['monotonically_converging'] else '⚠ Investigate'}

**Exergy Analysis:**
• Total Loss: {analysis['exergy_loss']:.6e}
• Loss Rate: {analysis['exergy_loss_rate']:.6e}
• Trend: {analysis['exergy_trend']:.6e}

**Thermodynamic Compliance:**
• Energy Conservation: ✓ Maintained
• No Energy Creation: ✓ Confirmed
• No Entropy Reversal: ✓ Confirmed
        """.strip()

        conclusions = f"""
**Summary:**
The engine demonstrates {'successful' if results['converged'] and results['cycle_count'] <= 7 else 'suboptimal'} operation.

**Strengths:**
• ΔΩ constraint satisfied: {results['cycle_count'] <= 7}
• Closure achieved: {results['closure_achieved']}
• Thermodynamic compliance: ✓

**Areas for Improvement:**
{f"• Cycle count optimization ({results['cycle_count']} cycles)" if results['cycle_count'] > 7 else ""}
{f"• Exergy half-life adjustment ({results['half_life']:.4f}s)" if not (0.18 <= results['half_life'] <= 0.24) else ""}
{f"• Stability investigation" if not analysis['monotonically_converging'] else ""}

**Next Steps:**
• Parameter optimization
• Domain extension testing
• Comparative benchmarking
        """.strip()

        presentation = self.templates['presentation'].format(
            title=title,
            authors="Conner Brown-Milliken (@Wotcnt)",
            overview=overview,
            methodology=methodology,
            results=results_text,
            analysis=analysis_text,
            conclusions=conclusions
        )

        return presentation

    def export_to_markdown(self, content: str, filename: str):
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"Exported to {filename}")

    def export_to_json(self, results: Dict, analysis: Dict, filename: str):
        data = {
            'timestamp': datetime.datetime.now().isoformat(),
            'results': self._serialize_tensor(results),
            'analysis': analysis,
            'config': {
                'device': str(self.engine.device),
                'dtype': str(self.engine.dtype),
                'delta_omega': self.engine.config.delta_omega,
                'convergence_threshold': self.engine.config.convergence_threshold
            }
        }

        with open(filename, 'w') as f:
            json.dump(data, f, indent=2, default=str)
        print(f"Exported to {filename}")

    def _serialize_tensor(self, data: Dict) -> Dict:
        serialized = {}
        for key, value in data.items():
            if isinstance(value, torch.Tensor):
                serialized[key] = value.tolist()
            elif isinstance(value, dict):
                serialized[key] = self._serialize_tensor(value)
            elif isinstance(value, list):
                serialized[key] = [
                    item.tolist() if isinstance(item, torch.Tensor) else item
                    for item in value
                ]
            else:
                serialized[key] = value
        return serialized


class CitationGenerator:
    @staticmethod
    def generate_apa(metadata: PaperMetadata) -> str:
        authors = ", & ".join(metadata.authors)
        year = metadata.date.split(",")[-1].strip()
        return f"{authors} ({year}). {metadata.title}. {metadata.affiliation}."

    @staticmethod
    def generate_bibtex(metadata: PaperMetadata) -> str:
        first_author = metadata.authors[0].split()[-1].lower()
        year = metadata.date.split(",")[-1].strip()
        key = f"{first_author}{year}"

        bibtex = f"""@misc{{{key},
  title = {{{metadata.title}}},
  author = {{{', '.join(metadata.authors)}}},
  affiliation = {{{metadata.affiliation}}},
  year = {{{year}}},
  note = {{Polyrifringence Engine, ΔΩΩΔ-Validated Framework}}
}}"""
        return bibtex

    @staticmethod
    def generate_mla(metadata: PaperMetadata) -> str:
        authors = ", and ".join(metadata.authors)
        return f'{authors}. "{metadata.title}." {metadata.affiliation}, {metadata.date}.'


def main():
    from .core_engine import PolyrifringenceEngine, EngineConfig
    from .analysis_toolkit import TraceAnalyzer

    config = EngineConfig()
    engine = PolyrifringenceEngine(config)

    E_initial = torch.tensor([1.0, 0.5], dtype=torch.complex128)
    E_initial = E_initial / torch.norm(E_initial)

    theta_seq = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]
    lambda_seq = [500e-9] * len(theta_seq)

    results = engine.run_recursion(E_initial, theta_seq, lambda_seq)

    analyzer = TraceAnalyzer(engine)
    analysis = analyzer.analyze_recursion_trace(results)

    doc_gen = DocumentationGenerator(engine)

    report = doc_gen.generate_analysis_report(results, analysis)
    doc_gen.export_to_markdown(report, "analysis_report.md")

    metadata = PaperMetadata(
        title="Recursive Birefringence with Symbolic Constraints: The Polyrifringence Engine",
        authors=["Conner Brown-Milliken"],
        affiliation="NinjaTech AI",
        abstract="This work presents a GPU-accelerated recursive simulation framework for modeling birefringence with feedback loops and symbolic constraints.",
        keywords=["birefringence", "recursion", "exergy", "coherence", "GPU acceleration"]
    )

    paper = doc_gen.generate_academic_paper(metadata, results, analysis)
    doc_gen.export_to_markdown(paper, "academic_paper.md")

    presentation = doc_gen.generate_presentation(results, analysis)
    doc_gen.export_to_markdown(presentation, "presentation.md")

    print("\nCitations:")
    print(f"APA: {CitationGenerator.generate_apa(metadata)}")
    print(f"\nBibTeX:\n{CitationGenerator.generate_bibtex(metadata)}")

    print("\nDocumentation generated successfully!")


if __name__ == "__main__":
    main()
